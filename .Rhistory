spread(term, estimate) %>%
select(-id)
se.out <- df_tidy %>%
select(id, term, std.error) %>%
spread(term, std.error) %>%
select(-id)
combined.results <- mi.meld(q = coef.out, se = se.out)
data_frame(term = colnames(combined.results$q.mi),
estimate.mi = combined.results$q.mi[1, ],
std.error.mi = combined.results$se.mi[1, ])
}
# compare results
tidy(missing_biden) %>%
left_join(mi.meld.plus(models_trans_imp)) %>%
select(-statistic, -p.value)
df_lite.out <- amelia(df_lite, m = 5)
models_trans_imp <- data_frame(data = df_lite.out$imputations) %>%
mutate(model = map(data, ~ lm(sqrt(biden) ~ log(age) +
female + sqrt(educ),
data = .x)),
coef = map(model, tidy)) %>%
unnest(coef, .id = "id")
models_trans_imp
# compare results
mi.meld.plus <- function(df_tidy){
# transform data into appropriate matrix shape
coef.out <- df_tidy %>%
select(id:estimate) %>%
spread(term, estimate) %>%
select(-id)
se.out <- df_tidy %>%
select(id, term, std.error) %>%
spread(term, std.error) %>%
select(-id)
combined.results <- mi.meld(q = coef.out, se = se.out)
data_frame(term = colnames(combined.results$q.mi),
estimate.mi = combined.results$q.mi[1, ],
std.error.mi = combined.results$se.mi[1, ])
}
# compare results
tidy(missing_biden) %>%
left_join(mi.meld.plus(models_trans_imp)) %>%
select(-statistic, -p.value)
models_trans_imp <- data_frame(data = df_lite.out$imputations) %>%
mutate(model = map(data, ~ lm(biden ~ log(age) +
female + educ,
data = .x)),
coef = map(model, tidy)) %>%
unnest(coef, .id = "id")
models_trans_imp
# compare results
mi.meld.plus <- function(df_tidy){
# transform data into appropriate matrix shape
coef.out <- df_tidy %>%
select(id:estimate) %>%
spread(term, estimate) %>%
select(-id)
se.out <- df_tidy %>%
select(id, term, std.error) %>%
spread(term, std.error) %>%
select(-id)
combined.results <- mi.meld(q = coef.out, se = se.out)
data_frame(term = colnames(combined.results$q.mi),
estimate.mi = combined.results$q.mi[1, ],
std.error.mi = combined.results$se.mi[1, ])
}
# compare results
tidy(missing_biden) %>%
left_join(mi.meld.plus(models_trans_imp)) %>%
select(-statistic, -p.value)
models_trans_imp <- data_frame(data = df_lite.out$imputations) %>%
mutate(model = map(data, ~ lm(biden ~ age +
female + educ,
data = .x)),
coef = map(model, tidy)) %>%
unnest(coef, .id = "id")
models_trans_imp
# compare results
mi.meld.plus <- function(df_tidy){
# transform data into appropriate matrix shape
coef.out <- df_tidy %>%
select(id:estimate) %>%
spread(term, estimate) %>%
select(-id)
se.out <- df_tidy %>%
select(id, term, std.error) %>%
spread(term, std.error) %>%
select(-id)
combined.results <- mi.meld(q = coef.out, se = se.out)
data_frame(term = colnames(combined.results$q.mi),
estimate.mi = combined.results$q.mi[1, ],
std.error.mi = combined.results$se.mi[1, ])
}
# compare results
tidy(missing_biden) %>%
left_join(mi.meld.plus(models_trans_imp)) %>%
select(-statistic, -p.value)
models_trans_imp <- data_frame(data = df_lite.out$imputations) %>%
mutate(model = map(data, ~ lm(biden^2 ~ log(age) +
female + educ^2,
data = .x)),
coef = map(model, tidy)) %>%
unnest(coef, .id = "id")
models_trans_imp
# compare results
mi.meld.plus <- function(df_tidy){
# transform data into appropriate matrix shape
coef.out <- df_tidy %>%
select(id:estimate) %>%
spread(term, estimate) %>%
select(-id)
se.out <- df_tidy %>%
select(id, term, std.error) %>%
spread(term, std.error) %>%
select(-id)
combined.results <- mi.meld(q = coef.out, se = se.out)
data_frame(term = colnames(combined.results$q.mi),
estimate.mi = combined.results$q.mi[1, ],
std.error.mi = combined.results$se.mi[1, ])
}
# compare results
tidy(missing_biden) %>%
left_join(mi.meld.plus(models_trans_imp)) %>%
select(-statistic, -p.value)
models_trans_imp <- data_frame(data = df_lite.out$imputations) %>%
mutate(model = map(data, ~ lm(biden ~ age +
female + educ,
data = .x)),
coef = map(model, tidy)) %>%
unnest(coef, .id = "id")
models_trans_imp
# compare results
mi.meld.plus <- function(df_tidy){
# transform data into appropriate matrix shape
coef.out <- df_tidy %>%
select(id:estimate) %>%
spread(term, estimate) %>%
select(-id)
se.out <- df_tidy %>%
select(id, term, std.error) %>%
spread(term, std.error) %>%
select(-id)
combined.results <- mi.meld(q = coef.out, se = se.out)
data_frame(term = colnames(combined.results$q.mi),
estimate.mi = combined.results$q.mi[1, ],
std.error.mi = combined.results$se.mi[1, ])
}
# compare results
tidy(missing_biden) %>%
left_join(mi.meld.plus(models_trans_imp)) %>%
select(-statistic, -p.value)
knitr::opts_chunk$set(echo = TRUE)
library(broom)
library(car)
library(modelr)
library(lmtest)
library(GGally)
library(plotly)
library(stringr)
library(Amelia)
library(rcfss)
knitr::opts_chunk$set(echo = TRUE)
install.packages('rcfss')
library(broom)
library(car)
library(modelr)
library(lmtest)
library(GGally)
library(plotly)
library(stringr)
library(Amelia)
library(rcfss)
knitr::opts_chunk$set(echo = TRUE)
library(broom)
library(car)
library(modelr)
library(lmtest)
library(GGally)
library(plotly)
library(stringr)
library(Amelia)
library(RColorBrewer)
library(forcats)
options(digits = 3)
set.seed(1234)
theme_set(theme_minimal())
knitr::opts_chunk$set(echo = TRUE)
library(broom)
library(car)
library(modelr)
library(lmtest)
library(GGally)
library(plotly)
library(stringr)
library(Amelia)
library(RColorBrewer)
library(forcats)
options(digits = 3)
set.seed(1234)
theme_set(theme_minimal())
biden_df = read.csv('biden.csv')
biden_df = na.omit(biden_df)
biden_mod <- lm(biden ~ age + female + educ, data = biden_df)
tidy(biden_mod)
# add key statistics
biden_augment <- biden_df %>%
mutate(hat = hatvalues(biden_mod),
student = rstudent(biden_mod),
cooksd = cooks.distance(biden_mod))
# draw bubble plot
ggplot(biden_augment, aes(hat, student)) +
geom_hline(yintercept = 0, linetype = 2) +
geom_point(aes(size = cooksd), shape = 1) +
geom_text(data = biden_augment %>%
arrange(-cooksd) %>%
slice(1:30),
aes(label = age)) +
scale_size_continuous(range = c(1, 20)) +
labs(x = "Leverage",
y = "Studentized residual") +
theme(legend.position = "none")
biden_augment %>%
filter(hat > 2 * mean(hat))
biden_augment %>%
filter(abs(student) > 2)
biden_augment %>%
filter(cooksd > 4 / (nrow(.) - (length(coef(biden_mod)) - 1) - 1))
car::qqPlot(biden_mod)
biden_copy <- biden_mod
augment(biden_copy, biden_df) %>%
mutate(.student = rstudent(biden_mod)) %>%
ggplot(aes(.student)) +
geom_density(adjust = .5) +
labs(x = "Studentized residuals",
y = "Estimated density")
biden_normal <- biden_df %>%
mutate(educ_power = educ^2)
biden_normal_mod <- lm(biden ~ age + female + educ_power, data = biden_normal)
tidy(biden_normal_mod)
car::qqPlot(biden_normal_mod)
biden_df %>%
add_predictions(biden_copy) %>%
add_residuals(biden_copy) %>%
ggplot(aes(pred, resid)) +
geom_point(alpha = .2) +
geom_hline(yintercept = 0, linetype = 2) +
geom_quantile(method = "rqss", lambda = 5, quantiles = c(.05, .95)) +
labs(title = "Variance of error terms",
x = "Predicted values",
y = "Residuals")
bptest(biden_mod)
cormat_heatmap <- function(data){
# generate correlation matrix
cormat <- round(cor(data), 2)
# melt into a tidy table
get_upper_tri <- function(cormat){
cormat[lower.tri(cormat)]<- NA
return(cormat)
}
upper_tri <- get_upper_tri(cormat)
# reorder matrix based on coefficient value
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}
cormat <- reorder_cormat(cormat)
upper_tri <- get_upper_tri(cormat)
# Melt the correlation matrix
melted_cormat <- reshape2::melt(upper_tri, na.rm = TRUE)
# Create a ggheatmap
ggheatmap <- ggplot(melted_cormat, aes(Var2, Var1, fill = value))+
geom_tile(color = "white")+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name="Pearson\nCorrelation") +
theme_minimal()+ # minimal theme
theme(axis.text.x = element_text(angle = 45, vjust = 1,
size = 12, hjust = 1))+
coord_fixed()
# add correlation values to graph
ggheatmap +
geom_text(aes(Var2, Var1, label = value), color = "black", size = 4) +
theme(
axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank(),
legend.position = "bottom")
}
cormat_heatmap(select_if(biden_df, is.numeric))
ggpairs(select_if(biden_df, is.numeric))
age_female <- lm(biden ~ age + female, data = biden_df)
car::vif(age_female)
female_educ <- lm(biden ~ educ + female, data = biden_df)
car::vif(female_educ)
age_educ <- lm(biden ~ age + educ, data = biden_df)
car::vif(age_educ)
inter_biden <- lm(biden ~ age * educ, data=biden_df)
tidy(inter_biden)
glance(inter_biden)
# function to get point estimates and standard errors
# model - lm object
# mod_var - name of moderating variable in the interaction
instant_effect <- function(model, mod_var){
# get interaction term name
int.name <- names(model$coefficients)[[which(str_detect(names(model$coefficients), ":"))]]
marg_var <- str_split(int.name, ":")[[1]][[which(str_split(int.name, ":")[[1]] != mod_var)]]
# store coefficients and covariance matrix
beta.hat <- coef(model)
cov <- vcov(model)
# possible set of values for mod_var
if(class(model)[[1]] == "lm"){
z <- seq(min(model$model[[mod_var]]), max(model$model[[mod_var]]))
} else {
z <- seq(min(model$data[[mod_var]]), max(model$data[[mod_var]]))
}
# calculate instantaneous effect
dy.dx <- beta.hat[[marg_var]] + beta.hat[[int.name]] * z
# calculate standard errors for instantaeous effect
se.dy.dx <- sqrt(cov[marg_var, marg_var] +
z^2 * cov[int.name, int.name] +
2 * z * cov[marg_var, int.name])
# combine into data frame
data_frame(z = z,
dy.dx = dy.dx,
se = se.dy.dx)
}
# point range plot
instant_effect(inter_biden, "educ") %>%
ggplot(aes(z, dy.dx,
ymin = dy.dx - 1.96 * se,
ymax = dy.dx + 1.96 * se)) +
geom_pointrange() +
geom_hline(yintercept = 0, linetype = 2) +
labs(title = "Marginal effect of age",
subtitle = "By respondent education level",
x = "Respondent education level",
y = "Estimated marginal effect")
coef(inter_biden)[["educ"]] + coef(inter_biden)[["age:educ"]]
vcov(inter_biden)
sqrt(vcov(inter_biden)["age", "age"] +
(1)^2 * vcov(inter_biden)["age:educ", "age:educ"] +
2 * 1 * vcov(inter_biden)["age", "age:educ"])
# point range plot
instant_effect(inter_biden, "age") %>%
ggplot(aes(z, dy.dx,
ymin = dy.dx - 1.96 * se,
ymax = dy.dx + 1.96 * se)) +
geom_pointrange() +
geom_hline(yintercept = 0, linetype = 2) +
labs(title = "Marginal effect of education",
subtitle = "By respondent age",
x = "Respondent age",
y = "Estimated marginal effect")
coef(inter_biden)[["age"]] + coef(inter_biden)[["age:educ"]]
vcov(inter_biden)
sqrt(vcov(inter_biden)["educ", "educ"] +
(1)^2 * vcov(inter_biden)["age:educ", "age:educ"] +
2 * 1 * vcov(inter_biden)["educ", "age:educ"])
df = read.csv('biden.csv')
missing_biden <- lm(biden ~ age + female + educ, data=df)
tidy(missing_biden)
missmap(df.out)
df.out <- amelia(as.data.frame(df), m = 5)
missmap(df.out)
df %>%
select(biden, age, female, educ) %>%
summarize_all(funs(sum(is.na(.)))) %>%
knitr::kable()
df %>%
select(biden, age, female, educ) %>%
summarize_all(funs(sum(is.na(.)))) %>%
knitr::kable()
install.packages('rcfss')
cormat_heatmap <- function(data){
# generate correlation matrix
cormat <- round(cor(data), 2)
# melt into a tidy table
get_upper_tri <- function(cormat){
cormat[lower.tri(cormat)]<- NA
return(cormat)
}
upper_tri <- get_upper_tri(cormat)
# reorder matrix based on coefficient value
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}
cormat <- reorder_cormat(cormat)
upper_tri <- get_upper_tri(cormat)
# Melt the correlation matrix
melted_cormat <- reshape2::melt(upper_tri, na.rm = TRUE)
# Create a ggheatmap
ggheatmap <- ggplot(melted_cormat, aes(Var2, Var1, fill = value))+
geom_tile(color = "white")+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name="Pearson\nCorrelation") +
theme_minimal()+ # minimal theme
theme(axis.text.x = element_text(angle = 45, vjust = 1,
size = 12, hjust = 1))+
coord_fixed()
# add correlation values to graph
ggheatmap +
geom_text(aes(Var2, Var1, label = value), color = "black", size = 4) +
theme(
axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank(),
legend.position = "bottom")
}
cormat_heatmap(biden_df, is.numeric)
cormat_heatmap <- function(data){
# generate correlation matrix
cormat <- round(cor(data), 2)
# melt into a tidy table
get_upper_tri <- function(cormat){
cormat[lower.tri(cormat)]<- NA
return(cormat)
}
upper_tri <- get_upper_tri(cormat)
# reorder matrix based on coefficient value
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}
cormat <- reorder_cormat(cormat)
upper_tri <- get_upper_tri(cormat)
# Melt the correlation matrix
melted_cormat <- reshape2::melt(upper_tri, na.rm = TRUE)
# Create a ggheatmap
ggheatmap <- ggplot(melted_cormat, aes(Var2, Var1, fill = value))+
geom_tile(color = "white")+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name="Pearson\nCorrelation") +
theme_minimal()+ # minimal theme
theme(axis.text.x = element_text(angle = 45, vjust = 1,
size = 12, hjust = 1))+
coord_fixed()
# add correlation values to graph
ggheatmap +
geom_text(aes(Var2, Var1, label = value), color = "black", size = 4) +
theme(
axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank(),
legend.position = "bottom")
}
cormat_heatmap(biden_df)
knitr::opts_chunk$set(echo = TRUE)
library(broom)
library(car)
library(modelr)
library(lmtest)
library(GGally)
library(plotly)
library(stringr)
library(Amelia)
library(RColorBrewer)
library(forcats)
library(dplyr)
options(digits = 3)
set.seed(1234)
theme_set(theme_minimal())
knitr::opts_chunk$set(echo = TRUE)
library(broom)
library(car)
library(modelr)
library(lmtest)
library(GGally)
library(plotly)
library(stringr)
library(Amelia)
library(RColorBrewer)
library(forcats)
library(dplyr)
library(purrr)
options(digits = 3)
set.seed(1234)
theme_set(theme_minimal())
knitr::opts_chunk$set(echo = TRUE)
library(broom)
library(car)
library(modelr)
library(lmtest)
library(GGally)
library(plotly)
library(stringr)
library(Amelia)
library(RColorBrewer)
library(forcats)
library(dplyr)
library(purrr)
library(tidyr)
options(digits = 3)
set.seed(1234)
theme_set(theme_minimal())
